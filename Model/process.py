import numpy as np
import random

def extract_train_by_participant(x):
    '''
    Extract training sample group by participants.
    
    :param dict x: ML data generated by FIC preprocessing.

    :return list x_train_all_p: list of training data by participant.
    :return list y_train_all_p: list of training labels by participant.
    '''
    subject = x['subject']
    x_train_all_p = []
    y_train_all_p = []

    for each_participant in list(set(subject)):
        indexes = [i for i,x in enumerate(subject) if x == each_participant]
        # merge sessions by participant
        x_train_p = np.array(x['x_train_all'])[indexes]
        y_train_p = np.array(x['y_train_all'])[indexes]

        if(len(indexes)==1):
            x_train_all_p.append(x_train_p[0])
            y_train_all_p.append(y_train_p[0])
        else:
            x_train_all_p.append(np.vstack(x_train_p))
            y_train_all_p.append(np.hstack(y_train_p))
    return(x_train_all_p, y_train_all_p)


def subsample_by_participant(x_train_all_p, y_train_all_p, p, method = 'random'):
    '''
    Subsample to balance positive and negative classes
    
    :param list x_train_all_p: list of training data by participant.
    :param list y_train_all_p: list of training labels by participant.
    :param int p: selected participant ID.
    :param string method: subsampling methods (random/distance-based).

    :return list x_train_sublist: list of training data by 5 pos:neg ratios (1:1 to 1:3).
    :return list y_train_sublist: list of training labels by 5 pos:neg ratios (1:1 to 1:3).
    '''
    x_train = x_train_all_p[p-1]
    y_train = y_train_all_p[p-1]

    pos_idx = [i for i, e in enumerate(y_train) if e == 1]
    neg_idx = [i for i, e in enumerate(y_train) if e == 0]

    x_train_pos = x_train[pos_idx]
    x_train_neg = x_train[neg_idx]

    # get 1:1, 1:2, and 1:3 positive/negative class with dtw distance descending
    len_pos = len(pos_idx)
    x_train_sublist = []
    y_train_sublist = []

    for each_len in [int(len_pos), int(len_pos*2), int(len_pos*3), int(len_pos*4),int(len_pos*5)]:
        if(method == 'random'):
            neg_temp = random.sample(list(x_train_neg), each_len)
            
        elif(method == 'distance'):
            dist_list = []
            for each_neg in x_train_neg:
                dist = 0
                for each_pos in x_train_pos:
                    dist = dist + dtw(each_neg, each_pos)
                dist_list.append(dist)
            
            idx_top_n = sorted(range(len(dist_list)), key=lambda i: dist_list[i])[-1 * each_len:]
            neg_temp = x_train_neg[idx_top_n]
        else:
            print('invalid subsampling method')
            break
        
        labels = [1] * len_pos + [0] * each_len
        x_train_temp = np.append(x_train_pos, neg_temp, axis = 0)
        x_train_sublist.append(x_train_temp)
        y_train_sublist.append(labels)
    
    return(x_train_sublist, y_train_sublist)